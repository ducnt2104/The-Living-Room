<!doctype html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mô Phỏng Trận Bạch Đằng 938 & Các Di Tích</title>
    <link rel="shortcut icon" href="../../favicon.svg" type="image/x-icon" />
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #000;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      }
      #canvas-container {
        width: 100vw;
        height: 100vh;
        display: block;
      }
      #ui-layer {
        position: absolute;
        top: 20px;
        left: 20px;
        color: #fff;
        pointer-events: none;
        background: rgba(0, 0, 0, 0.6);
        padding: 15px 25px;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        backdrop-filter: blur(4px);
      }
      h1 {
        margin: 0 0 10px 0;
        font-size: 20px;
        color: #ffaa55;
        text-transform: uppercase;
        letter-spacing: 1px;
      }
      p {
        margin: 5px 0;
        font-size: 14px;
        color: #ccc;
      }
      .instruction {
        margin-top: 15px;
        font-size: 12px;
        color: #88ccff;
        font-style: italic;
      }
    </style>
    <!-- Khai báo Import Map cho Three.js ES Modules -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
      }
    </script>
  </head>
  <body>
    <div id="ui-layer">
      <h1>Trận Bạch Đằng (938)</h1>
      <p id="status-text">Trạng thái: Nước đang lớn...</p>
      <p class="instruction">
        Chuột trái: Xoay | Chuột phải: Kéo (Pan) đến các di tích (Trục X) |
        Cuộn: Zoom
      </p>
    </div>

    <div id="canvas-container"></div>

    <script type="module">
      /**
       * ==========================================
       * TẬP TIN: bach-dang-938.js (ES Module)
       * TÁC GIẢ: Senior Frontend Developer
       * MÔ TẢ: Mô phỏng trận Bạch Đằng 938 & 5 Di Tích
       * ==========================================
       */

      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      // --- BIẾN TOÀN CỤC ---
      let scene, camera, renderer, controls, clock;

      // I. BIẾN PHẦN 1: MÔ PHỎNG TRẬN CHIẾN
      let bachDangRiverMesh;
      let stakeFieldGroup, mainRiverStakesGroup, secondaryChannelStakesGroup;
      let namHanFleetGroup, hoangThaoShipMesh;
      let ngoQuyenFleetGroup, decoyBoatsGroup;

      // Hệ thống hạt (Particles) cho nước bắn
      let splashParticlesGroup;

      // Cơ chế thủy triều & State Machine
      let tideLevel = 0; // Mức nước hiện tại
      let tideDirection = -1; // -1: rút, 1: dâng
      const HIGH_TIDE_Y = 0;
      const LOW_TIDE_Y = -6; // Nước rút xuống -6 để lộ cọc (cọc cao 8, base ở -6 -> đầu cọc ở +2)
      let simulationTime = 0;
      let simulationPhase = "HIGH_TIDE"; // 'HIGH_TIDE', 'EBB_TIDE', 'DESTRUCTION', 'RESET'

      // II. BIẾN PHẦN 2: 5 DI TÍCH
      let caoQuyStakeFieldGroup;
      let bachDangGiangComplexGroup, ngoQuyenStatueMesh;
      let ngoQuyenTempleMesh;
      let museumStakeArtifactMesh;
      let hangKenhCommunalHouseMesh;

      // Cấu hình vật liệu tái sử dụng để tối ưu hiệu suất
      const materials = {
        wood: new THREE.MeshStandardMaterial({
          color: 0x3e2723,
          roughness: 0.9,
          metalness: 0.1,
        }),
        darkWood: new THREE.MeshStandardMaterial({
          color: 0x2d1a11,
          roughness: 0.9,
          metalness: 0.1,
        }),
        water: new THREE.MeshStandardMaterial({
          color: 0x1a3a5a,
          roughness: 0.2,
          metalness: 0.8,
          transparent: true,
          opacity: 0.9,
        }),
        stone: new THREE.MeshStandardMaterial({
          color: 0x78909c,
          roughness: 0.8,
          metalness: 0.2,
        }),
        redRoof: new THREE.MeshStandardMaterial({
          color: 0x8e24aa,
          roughness: 0.7,
          metalness: 0.1,
        }), // Tông đỏ gạch cổ
        gold: new THREE.MeshStandardMaterial({
          color: 0xffd700,
          roughness: 0.4,
          metalness: 0.8,
        }),
      };

      /**
       * Hàm khởi tạo chính
       */
      function initScene() {
        const container = document.getElementById("canvas-container");

        // 1. Setup Scene, Camera, Renderer
        scene = new THREE.Scene();
        // Tông màu sương mù hoàng hôn/bình minh mờ ảo
        scene.background = new THREE.Color(0x887766);
        scene.fog = new THREE.FogExp2(0x887766, 0.003);

        camera = new THREE.PerspectiveCamera(
          60,
          window.innerWidth / window.innerHeight,
          0.1,
          2000,
        );
        camera.position.set(0, 40, 60);

        renderer = new THREE.WebGLRenderer({
          antialias: true,
          alpha: false,
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Tối ưu cho màn hình retina
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        // 2. Setup Controls
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2 - 0.05; // Không cho lật dưới mặt đất
        controls.target.set(0, 0, 0);

        // 3. Setup Lighting
        // Ánh sáng môi trường (Ambient)
        const ambientLight = new THREE.AmbientLight(0x404050, 2.0); // Màu xanh dương tối
        scene.add(ambientLight);

        // Ánh sáng hướng (Directional) - Tượng trưng mặt trời hoàng hôn
        const dirLight = new THREE.DirectionalLight(0xffaa55, 3.0);
        dirLight.position.set(-50, 100, -50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 500;
        // Mở rộng vùng đổ bóng
        const d = 150;
        dirLight.shadow.camera.left = -d;
        dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d;
        dirLight.shadow.camera.bottom = -d;
        scene.add(dirLight);

        // 4. Khởi tạo các thành phần
        createBattleSimulation();
        createHistoricalSites();

        // 5. Utilities
        clock = new THREE.Clock();
        window.addEventListener("resize", onWindowResize);

        // 6. Start Loop
        animate();
      }

      /**
       * TẠO CHỮ 3D ĐƠN GIẢN (Bằng Canvas Texture để đảm bảo luôn chạy không cần load Font)
       */
      function createTextSprite(message, scale = 10) {
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        canvas.width = 512;
        canvas.height = 128;

        context.fillStyle = "rgba(0, 0, 0, 0.5)";
        context.roundRect(0, 0, canvas.width, canvas.height, 20);
        context.fill();

        context.font = "Bold 40px Arial";
        context.fillStyle = "#ffaa55";
        context.textAlign = "center";
        context.textBaseline = "middle";
        context.fillText(message, canvas.width / 2, canvas.height / 2);

        const texture = new THREE.CanvasTexture(canvas);
        const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.scale.set(scale, scale * 0.25, 1);

        return sprite;
      }

      /**
       * PHẦN 1: MÔ PHỎNG TRẬN CHIẾN
       */
      function createBattleSimulation() {
        // 1. Dòng sông Bạch Đằng
        // Dùng PlaneGeometry chia nhiều segment để tạo hiệu ứng sóng (vertex displacement)
        const riverGeo = new THREE.PlaneGeometry(400, 400, 64, 64);
        riverGeo.rotateX(-Math.PI / 2);
        bachDangRiverMesh = new THREE.Mesh(riverGeo, materials.water);
        bachDangRiverMesh.position.y = HIGH_TIDE_Y;
        bachDangRiverMesh.receiveShadow = true;

        // Lưu lại vị trí Y gốc của các đỉnh để tính toán sóng
        const posAttr = bachDangRiverMesh.geometry.attributes.position;
        bachDangRiverMesh.geometry.userData.originalY = [];
        for (let i = 0; i < posAttr.count; i++) {
          bachDangRiverMesh.geometry.userData.originalY.push(posAttr.getY(i));
        }
        scene.add(bachDangRiverMesh);

        // Đáy sông (để hứng bóng)
        const riverBedGeo = new THREE.PlaneGeometry(400, 400);
        riverBedGeo.rotateX(-Math.PI / 2);
        const riverBed = new THREE.Mesh(
          riverBedGeo,
          new THREE.MeshStandardMaterial({ color: 0x111111 }),
        );
        riverBed.position.y = LOW_TIDE_Y - 5;
        riverBed.receiveShadow = true;
        scene.add(riverBed);

        // 2. Hệ thống cọc ngầm
        stakeFieldGroup = new THREE.Group();
        mainRiverStakesGroup = new THREE.Group();
        secondaryChannelStakesGroup = new THREE.Group();

        // Geometry cọc vát nhọn đầu
        const stakeGeo = new THREE.CylinderGeometry(0, 0.6, 8, 5); // Đầu bán kính 0
        // Đẩy tâm (pivot) của cọc xuống đáy để dễ đặt vị trí
        stakeGeo.translate(0, 4, 0);

        // Hàm tạo một cụm cọc
        const createStakeCluster = (group, count, radius, centerX, centerZ) => {
          for (let i = 0; i < count; i++) {
            const stake = new THREE.Mesh(stakeGeo, materials.wood);
            const r = Math.sqrt(Math.random()) * radius;
            const theta = Math.random() * 2 * Math.PI;
            stake.position.set(
              centerX + r * Math.cos(theta),
              LOW_TIDE_Y - 2, // Đóng sâu dưới lòng sông
              centerZ + r * Math.sin(theta),
            );
            // Nghiêng nhẹ cho tự nhiên
            stake.rotation.x = (Math.random() - 0.5) * 0.3;
            stake.rotation.z = (Math.random() - 0.5) * 0.3;
            stake.castShadow = true;
            stake.receiveShadow = true;
            group.add(stake);
          }
        };

        // Trận địa chính ở cửa sông
        createStakeCluster(mainRiverStakesGroup, 150, 40, 0, 0);
        // Các lạch phụ hai bên
        createStakeCluster(secondaryChannelStakesGroup, 50, 20, -40, 20);
        createStakeCluster(secondaryChannelStakesGroup, 50, 20, 40, 20);

        stakeFieldGroup.add(mainRiverStakesGroup);
        stakeFieldGroup.add(secondaryChannelStakesGroup);
        scene.add(stakeFieldGroup);

        // 3. Thuyền chiến Nam Hán (Thuyền lớn)
        namHanFleetGroup = new THREE.Group();

        const createShip = (isLarge, colorMat) => {
          const shipGroup = new THREE.Group();
          // Thân thuyền
          const hullGeo = new THREE.BoxGeometry(
            isLarge ? 6 : 3,
            isLarge ? 4 : 2,
            isLarge ? 16 : 8,
          );
          // Vát đầu thuyền
          const pos = hullGeo.attributes.position;
          for (let i = 0; i < pos.count; i++) {
            if (pos.getZ(i) > 0) {
              // Mũi thuyền
              pos.setX(i, pos.getX(i) * 0.2);
            }
          }
          hullGeo.computeVertexNormals();
          const hull = new THREE.Mesh(hullGeo, colorMat);
          hull.position.y = isLarge ? 2 : 1;
          hull.castShadow = true;
          shipGroup.add(hull);

          // Cột buồm
          const mastGeo = new THREE.CylinderGeometry(
            0.2,
            0.2,
            isLarge ? 12 : 6,
          );
          const mast = new THREE.Mesh(mastGeo, materials.wood);
          mast.position.y = isLarge ? 8 : 4;
          mast.castShadow = true;
          shipGroup.add(mast);

          // Buồm
          const sailGeo = new THREE.PlaneGeometry(
            isLarge ? 8 : 4,
            isLarge ? 8 : 4,
          );
          const sailMat = new THREE.MeshStandardMaterial({
            color: 0xaa2222,
            side: THREE.DoubleSide,
          });
          const sail = new THREE.Mesh(sailGeo, sailMat);
          sail.position.y = isLarge ? 8 : 4;
          sail.position.z = 1; // Hơi lệch lên mũi
          sail.castShadow = true;
          shipGroup.add(sail);

          return shipGroup;
        };

        hoangThaoShipMesh = createShip(true, materials.darkWood);
        hoangThaoShipMesh.position.set(0, HIGH_TIDE_Y, -80);
        // Lưu dữ liệu ban đầu để mô phỏng
        hoangThaoShipMesh.userData = {
          origY: HIGH_TIDE_Y,
          phase: "sailing",
        };
        namHanFleetGroup.add(hoangThaoShipMesh);

        // Thêm vài thuyền Nam Hán phụ
        for (let i = 0; i < 4; i++) {
          const ship = createShip(true, materials.darkWood);
          ship.position.set(
            (Math.random() - 0.5) * 40,
            HIGH_TIDE_Y,
            -100 - Math.random() * 30,
          );
          ship.userData = { origY: HIGH_TIDE_Y, phase: "sailing" };
          namHanFleetGroup.add(ship);
        }
        scene.add(namHanFleetGroup);

        // 4. Thuyền nhẹ quân Ngô Quyền
        ngoQuyenFleetGroup = new THREE.Group();
        decoyBoatsGroup = new THREE.Group();

        for (let i = 0; i < 6; i++) {
          const boat = createShip(false, materials.wood);
          boat.position.set(
            (Math.random() - 0.5) * 50,
            HIGH_TIDE_Y,
            20 + Math.random() * 20,
          );
          // Cắm cờ màu khác
          boat.children[2].material.color.setHex(0xaaaaaa);
          boat.rotation.y = Math.PI; // Xoay ngược lại giả vờ chạy
          decoyBoatsGroup.add(boat);
        }
        ngoQuyenFleetGroup.add(decoyBoatsGroup);
        scene.add(ngoQuyenFleetGroup);

        // Khởi tạo Particle Group cho bọt nước khi chìm
        splashParticlesGroup = new THREE.Group();
        scene.add(splashParticlesGroup);
      }

      /**
       * PHẦN 2: 5 DI TÍCH & HIỆN VẬT
       * Đặt các cụm di tích dọc theo trục X: 150, 250, 350, 450, 550
       */
      function createHistoricalSites() {
        // Cấu trúc nền chung cho các khu trưng bày
        const createPedestal = (x, z, size, title) => {
          const baseGeo = new THREE.BoxGeometry(size, 2, size);
          const base = new THREE.Mesh(baseGeo, materials.stone);
          base.position.set(x, -1, z);
          base.receiveShadow = true;
          base.castShadow = true;
          scene.add(base);

          const label = createTextSprite(title, size * 0.8);
          label.position.set(x, 15, z);
          scene.add(label);
        };

        // 1. Bãi cọc Cao Quỳ (Hải Phòng)
        const x1 = 150;
        createPedestal(x1, 0, 40, "1. Bãi cọc Cao Quỳ (Phát hiện 2019)");
        caoQuyStakeFieldGroup = new THREE.Group();
        const miniStakeGeo = new THREE.CylinderGeometry(0.3, 0.4, 4);
        for (let i = 0; i < 30; i++) {
          const st = new THREE.Mesh(miniStakeGeo, materials.wood);
          st.position.set(
            x1 + (Math.random() - 0.5) * 30,
            1,
            (Math.random() - 0.5) * 30,
          );
          st.rotation.x = (Math.random() - 0.5) * 0.5;
          st.castShadow = true;
          caoQuyStakeFieldGroup.add(st);
        }
        scene.add(caoQuyStakeFieldGroup);

        // 2. Khu di tích Bạch Đằng Giang
        const x2 = 250;
        createPedestal(x2, 0, 40, "2. Bạch Đằng Giang (Tượng 3 danh tướng)");
        bachDangGiangComplexGroup = new THREE.Group();
        const statueGeo = new THREE.CapsuleGeometry(1.5, 6, 4, 8);

        // Ngô Quyền (Giữa, cao hơn)
        ngoQuyenStatueMesh = new THREE.Mesh(statueGeo, materials.stone);
        ngoQuyenStatueMesh.position.set(x2, 4, 0);
        ngoQuyenStatueMesh.scale.set(1.2, 1.2, 1.2);
        ngoQuyenStatueMesh.castShadow = true;
        bachDangGiangComplexGroup.add(ngoQuyenStatueMesh);

        // Lê Hoàn & Trần Hưng Đạo
        const stat2 = new THREE.Mesh(statueGeo, materials.stone);
        stat2.position.set(x2 - 8, 3, 5);
        stat2.castShadow = true;
        bachDangGiangComplexGroup.add(stat2);

        const stat3 = new THREE.Mesh(statueGeo, materials.stone);
        stat3.position.set(x2 + 8, 3, 5);
        stat3.castShadow = true;
        bachDangGiangComplexGroup.add(stat3);

        scene.add(bachDangGiangComplexGroup);

        // 3. Đền thờ Ngô Quyền (Đường Lâm)
        const x3 = 350;
        createPedestal(x3, 0, 40, "3. Đền thờ Ngô Quyền (Đường Lâm)");
        ngoQuyenTempleMesh = new THREE.Group();

        // Thân đền
        const templeBody = new THREE.Mesh(
          new THREE.BoxGeometry(20, 8, 15),
          materials.wood,
        );
        templeBody.position.set(x3, 4, 0);
        templeBody.castShadow = true;
        ngoQuyenTempleMesh.add(templeBody);

        // Mái cong (dùng Pyramid)
        const roofGeo = new THREE.ConeGeometry(16, 6, 4);
        roofGeo.rotateY(Math.PI / 4); // Xoay cho khớp Box
        const roof = new THREE.Mesh(roofGeo, materials.redRoof);
        roof.position.set(x3, 11, 0);
        roof.scale.set(1, 1, 0.7);
        roof.castShadow = true;
        ngoQuyenTempleMesh.add(roof);
        scene.add(ngoQuyenTempleMesh);

        // 4. Cọc gỗ trưng bày (Bảo tàng)
        const x4 = 450;
        createPedestal(x4, 0, 30, "4. Hiện vật Cọc gỗ (Bảo tàng QG)");
        museumStakeArtifactMesh = new THREE.Group();

        // Bệ kính
        const glassBase = new THREE.Mesh(
          new THREE.BoxGeometry(4, 2, 4),
          materials.darkWood,
        );
        glassBase.position.set(x4, 1, 0);
        museumStakeArtifactMesh.add(glassBase);

        // Cọc gỗ
        const artifactGeo = new THREE.CylinderGeometry(0.5, 0.8, 8);
        const artifact = new THREE.Mesh(artifactGeo, materials.wood);
        artifact.position.set(x4, 6, 0);
        artifact.rotation.z = Math.PI / 6; // Đặt nghiêng trưng bày
        artifact.castShadow = true;
        museumStakeArtifactMesh.add(artifact);

        // Đèn chiếu spotlight
        const spotLight = new THREE.SpotLight(0xffffff, 5);
        spotLight.position.set(x4, 15, 5);
        spotLight.target = artifact;
        spotLight.angle = Math.PI / 6;
        scene.add(spotLight);

        scene.add(museumStakeArtifactMesh);

        // 5. Đình Hàng Kênh
        const x5 = 550;
        createPedestal(x5, 0, 50, "5. Đình Hàng Kênh (Hải Phòng)");
        hangKenhCommunalHouseMesh = new THREE.Group();

        // Sàn
        const floor = new THREE.Mesh(
          new THREE.BoxGeometry(30, 1, 20),
          materials.wood,
        );
        floor.position.set(x5, 0.5, 0);
        hangKenhCommunalHouseMesh.add(floor);

        // Cột (Nhiều cột đặc trưng đình làng)
        const colGeo = new THREE.CylinderGeometry(0.4, 0.4, 6);
        for (let i = 0; i < 5; i++) {
          for (let j = 0; j < 3; j++) {
            const col = new THREE.Mesh(colGeo, materials.darkWood);
            col.position.set(x5 - 12 + i * 6, 3.5, -8 + j * 8);
            col.castShadow = true;
            hangKenhCommunalHouseMesh.add(col);
          }
        }

        // Mái đình lớn
        const bRoofGeo = new THREE.BoxGeometry(34, 4, 24);
        const bRoof = new THREE.Mesh(bRoofGeo, materials.redRoof);
        bRoof.position.set(x5, 8, 0);
        bRoof.castShadow = true;
        hangKenhCommunalHouseMesh.add(bRoof);

        scene.add(hangKenhCommunalHouseMesh);
      }

      /**
       * Hàm sinh hạt nước bắn (Hiệu ứng chiến thắng/thuyền chìm)
       */
      function createSplash(x, z) {
        const particleCount = 20;
        const pGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const pMat = new THREE.MeshBasicMaterial({ color: 0xccffff });

        for (let i = 0; i < particleCount; i++) {
          const mesh = new THREE.Mesh(pGeo, pMat);
          mesh.position.set(
            x + (Math.random() - 0.5) * 5,
            tideLevel,
            z + (Math.random() - 0.5) * 5,
          );
          mesh.userData = {
            vY: Math.random() * 5 + 5, // Vận tốc nảy lên
            vX: (Math.random() - 0.5) * 5,
            vZ: (Math.random() - 0.5) * 5,
            life: 1.0,
          };
          splashParticlesGroup.add(mesh);
        }
      }

      /**
       * CƠ CHẾ THỦY TRIỀU & LOGIC TRẬN CHIẾN (QUAN TRỌNG)
       */
      function updateTide(delta) {
        simulationTime += delta;
        const uiStatus = document.getElementById("status-text");

        // 1. PHASE: HIGH TIDE (Nước lên, dụ địch)
        if (simulationTime < 10) {
          simulationPhase = "HIGH_TIDE";
          uiStatus.innerText =
            "Trạng thái: Nước lớn, che khuất bãi cọc. Thuyền Nam Hán tiến vào.";

          // Nam Hán tiến vào
          namHanFleetGroup.children.forEach((ship) => {
            if (ship.position.z < -20) ship.position.z += delta * 5;
          });

          // Ngô Quyền giả vờ rút lui (tiến sâu vào bờ)
          decoyBoatsGroup.children.forEach((boat) => {
            if (boat.position.z < 80) boat.position.z += delta * 8;
          });
        }
        // 2. PHASE: EBB TIDE (Nước rút)
        else if (simulationTime >= 10 && simulationTime < 20) {
          simulationPhase = "EBB_TIDE";
          uiStatus.innerText =
            "Trạng thái: Nước rút nhanh. Bãi cọc bắt đầu lộ diện!";

          // Giảm mức nước (Lerp)
          tideLevel = THREE.MathUtils.lerp(tideLevel, LOW_TIDE_Y, delta * 0.5);
          bachDangRiverMesh.position.y = tideLevel;

          // Thuyền hạ theo nước
          namHanFleetGroup.children.forEach((ship) => {
            ship.position.y = tideLevel + ship.userData.origY;
          });
        }
        // 3. PHASE: DESTRUCTION (Va cọc, chìm)
        else if (simulationTime >= 20 && simulationTime < 35) {
          if (simulationPhase !== "DESTRUCTION") {
            simulationPhase = "DESTRUCTION";
            // Đổi mục tiêu camera vào bãi cọc
            controls.target.set(0, 0, -20);
          }
          uiStatus.innerText =
            "Trạng thái: Chiến thắng! Thuyền Nam Hán mắc cọc và chìm.";

          // Logic thuyền chìm
          namHanFleetGroup.children.forEach((ship, index) => {
            if (ship.userData.phase !== "sunk") {
              // Rung lắc dữ dội
              ship.rotation.z = Math.sin(simulationTime * 20 + index) * 0.2;
              ship.rotation.x = Math.sin(simulationTime * 15 + index) * 0.1;

              // Chìm dần (Scale Y giảm hoặc Y tụt nhanh hơn nước)
              ship.position.y -= delta * 2;
              ship.rotation.x -= delta; // Nghiêng chúi mũi

              if (Math.random() < 0.1) {
                createSplash(ship.position.x, ship.position.z);
              }

              if (ship.position.y < LOW_TIDE_Y - 5) {
                ship.userData.phase = "sunk";
              }
            }
          });
        }
        // 4. RESET LOOP
        else if (simulationTime >= 35) {
          simulationTime = 0;
          tideLevel = HIGH_TIDE_Y;
          bachDangRiverMesh.position.y = tideLevel;

          // Reset Thuyền Nam Hán
          namHanFleetGroup.children.forEach((ship, index) => {
            ship.userData.phase = "sailing";
            ship.position.y = ship.userData.origY;
            ship.position.z = -80 - index * 15;
            ship.rotation.set(0, 0, 0);
          });

          // Reset Thuyền Ngô Quyền
          let rIdx = 0;
          decoyBoatsGroup.children.forEach((boat) => {
            boat.position.z = 20 + rIdx * 10;
            rIdx++;
          });

          // Reset Camera Target
          controls.target.set(0, 0, 0);
        }

        // Cập nhật Particles (Bọt nước)
        splashParticlesGroup.children.forEach((p) => {
          p.position.x += p.userData.vX * delta;
          p.position.y += p.userData.vY * delta;
          p.position.z += p.userData.vZ * delta;
          p.userData.vY -= 15 * delta; // Trọng lực
          p.userData.life -= delta;

          // Xoay nhẹ
          p.rotation.x += delta * 5;
          p.rotation.y += delta * 5;

          // Ẩn/xóa khi hết life
          if (p.userData.life <= 0) {
            p.position.y = -999;
          }
        });
      }

      /**
       * Animation Loop hoàn chỉnh
       */
      function animate() {
        requestAnimationFrame(animate);

        const delta = clock.getDelta();
        const time = clock.getElapsedTime();

        // 1. Cập nhật Controls
        controls.update();

        // 2. Hiệu ứng gợn sóng cho mặt sông (Vertex Displacement)
        if (bachDangRiverMesh) {
          const positions = bachDangRiverMesh.geometry.attributes.position;
          const origY = bachDangRiverMesh.geometry.userData.originalY;
          for (let i = 0; i < positions.count; i++) {
            const x = positions.getX(i);
            const z = positions.getZ(i);
            // Dùng Sine wave kết hợp x, z và thời gian
            const wave =
              Math.sin(x * 0.2 + time * 2) * 0.5 +
              Math.sin(z * 0.1 + time) * 0.3;
            positions.setY(i, origY[i] + wave);
          }
          positions.needsUpdate = true;
        }

        // 3. Chạy logic mô phỏng trận chiến (Thủy triều)
        // Chỉ chạy mô phỏng khi camera đang nhìn ở khu vực chiến trận (X gần 0)
        if (camera.position.x < 100) {
          updateTide(delta);
        }

        // 4. Render
        renderer.render(scene, camera);
      }

      /**
       * Xử lý khi thay đổi kích thước cửa sổ
       */
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // --- Khởi chạy ứng dụng ---
      initScene();

      // Đảm bảo tuân thủ yêu cầu Export của ES Module
      export { initScene };
    </script>
  </body>
</html>
